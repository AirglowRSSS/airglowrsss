from github import Github
from typing import Optional, List
from datetime import datetime
import logging
from enum import Enum

class IssueType(Enum):
    ERROR = "error"
    WARNING = "warning"

class SiteIssueManager:
    def __init__(self, token: str, repo_name: str):
        """
        Initialize the issue manager.
        
        Args:
            token: GitHub personal access token
            repo_name: Repository name in format "owner/repo"
        """
        self.github = Github(token)
        self.repo = self.github.get_repo(repo_name)
        self.logger = logging.getLogger(__name__)
        
        # Base labels for different types of issues
        self.BASE_LABELS = {
            IssueType.ERROR: "data_processing:error",
            IssueType.WARNING: "data_processing:warning"
        }
        
        # Specific sublabels for different types of processing issues
        self.SPECIFIC_LABELS = {
            # Error labels
            "FileNotFoundError": "error:missing_file",
            "BadLaserError": "error:laser_centerfinding",
            "LaserProcessingError": "error:laser_general",
            "InstrumentProcessingError": "error:instrument",
            
            # Warning labels
            "LaserWarning": "warning:laser",
            "DataQualityWarning": "warning:quality",
            "CalibrationWarning": "warning:calibration",
            "InstrumentWarning": "warning:instrument"
        }

    def get_specific_label(self, issue_type: str) -> str:
        """Get the specific label based on the issue type."""
        return self.SPECIFIC_LABELS.get(issue_type, f"{IssueType.ERROR.value}:general")

    def find_open_site_issue(self, site_id: str, issue_type: str = None, 
                            category: IssueType = IssueType.ERROR) -> Optional[object]:
        """
        Check if there's an existing open issue/warning for a specific site.
        
        Args:
            site_id: Identifier for the site
            issue_type: Optional specific type of issue to search for
            category: Whether this is an error or warning
        """
        base_label = self.BASE_LABELS[category]
        query = f'repo:{self.repo.full_name} is:issue is:open label:"{base_label}" site:{site_id}'
        
        if issue_type:
            specific_label = self.get_specific_label(issue_type)
            query += f' label:"{specific_label}"'
            
        open_issues = self.github.search_issues(query)
        
        for issue in open_issues:
            if f'[Site: {site_id}]' in issue.title:
                return issue
        return None

    def create_site_issue(self, site_id: str, message: str, issue_type: str,
                         category: IssueType = IssueType.ERROR,
                         additional_context: dict = None) -> object:
        """
        Create a new issue or warning for a site.
        
        Args:
            site_id: Identifier for the site
            message: Description of the issue
            issue_type: Type of issue/warning
            category: Whether this is an error or warning
            additional_context: Optional dictionary of additional information
        """
        base_label = self.BASE_LABELS[category]
        specific_label = self.get_specific_label(issue_type)
        
        prefix = "Warning" if category == IssueType.WARNING else "Error"
        title = f"[Site: {site_id}] {prefix}: {issue_type}"
        
        # Build additional context section if provided
        context_section = ""
        if additional_context:
            context_section = "\n## Additional Context\n"
            for key, value in additional_context.items():
                context_section += f"- {key}: {value}\n"
        
        body = f"""
## Site Information
- Site ID: {site_id}
- Detection Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
- Type: {issue_type}
- Category: {category.value}

## Details
{message}
{context_section}
## Processing Information
- This issue was automatically generated by the data processing pipeline
- Category: {base_label}
- Specific Type: {specific_label}
"""
        
        labels = [
            base_label,
            specific_label,
            f'site-{site_id}'
        ]
        
        return self.repo.create_issue(
            title=title,
            body=body,
            labels=labels
        )

    def handle_processing_issue(self, 
                              site_id: str,
                              message: str,
                              issue_type: str = None,
                              category: IssueType = IssueType.ERROR,
                              additional_context: dict = None) -> Optional[object]:
        """
        Main method to handle a processing issue (error or warning) for a site.
        
        Args:
            site_id: Identifier for the site
            message: The warning or error message
            issue_type: Type of issue (e.g., 'LaserWarning', 'BadLaserError')
            category: Whether this is an error or warning
            additional_context: Optional dictionary of additional information
        """
        try:
            # If issue_type not provided, use a generic type based on category
            if not issue_type:
                issue_type = f"Generic{category.value.capitalize()}"
            
            # Check for existing issue of the same type
            existing_issue = self.find_open_site_issue(site_id, issue_type, category)
            
            if existing_issue:
                self.logger.info(
                    f"Found existing open {category.value} for site {site_id} "
                    f"of type {issue_type}: {existing_issue.html_url}"
                )
                return existing_issue
            
            new_issue = self.create_site_issue(
                site_id=site_id,
                message=message,
                issue_type=issue_type,
                category=category,
                additional_context=additional_context
            )
            
            self.logger.info(
                f"Created new {category.value} for site {site_id} "
                f"of type {issue_type}: {new_issue.html_url}"
            )
            return new_issue
            
        except Exception as e:
            self.logger.error(f"Error handling {category.value} for site {site_id}: {str(e)}")
            raise
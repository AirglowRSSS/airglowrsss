from github import Github
from typing import Optional, List
from datetime import datetime
import logging
from enum import Enum

class IssueType(Enum):
    ERROR = "error"
    WARNING = "warning"

class SiteIssueManager:
    def __init__(self, token: str, repo_name: str):
        """
        Initialize the issue manager.
        
        Args:
            token: GitHub personal access token
            repo_name: Repository name in format "owner/repo"
        """
        self.github = Github(token)
        self.repo = self.github.get_repo(repo_name)
        self.logger = logging.getLogger(__name__)
        
        # Base labels for different types of issues
        self.BASE_LABELS = {
            IssueType.ERROR: "data_processing:error",
            IssueType.WARNING: "data_processing:warning"
        }
        
        # Specific labels for errors (exceptions)
        self.ERROR_LABELS = {
            "BadLaserError": "error:laser_centerfinding",
            "LaserProcessingError": "error:laser_general",
            "InstrumentProcessingError": "error:instrument",
            # Add other error types as needed
        }

    def get_error_label(self, error_type: str) -> str:
        """Get the specific label for an error type"""
        return self.ERROR_LABELS.get(error_type, "error:general")

    def find_open_site_issue(self, site_id: str, category: IssueType = IssueType.ERROR) -> Optional[object]:
        """
        Check if there's an existing open issue/warning for a specific site.
        
        Args:
            site_id: Identifier for the site
            category: Whether this is an error or warning
            
        Returns:
            GitHub Issue object if found, None otherwise
        """
        base_label = self.BASE_LABELS[category]
        query = f'repo:{self.repo.full_name} is:issue is:open label:"{base_label}" label:site:{site_id}'
        
        try:
            open_issues = list(self.github.search_issues(query))
            
            for issue in open_issues:
                return issue
                
        except Exception as e:
            self.logger.error(f"Error searching issues: {e}")
        
        return None

    def create_site_issue(self, site_id: str, message: str,
                         category: IssueType = IssueType.ERROR,
                         error_type: str = None,
                         additional_context: dict = None) -> object:
        """
        Create a new issue or warning for a site.
        
        Args:
            site_id: Identifier for the site
            message: Description or WarningLog instance
            category: Whether this is an error or warning
            error_type: Type of error if this is an error
            additional_context: Optional dictionary of additional information
        """
        base_label = self.BASE_LABELS[category]
        
        # Handle different cases for title and labels
        if category == IssueType.WARNING and hasattr(message, 'warning_title'):
            # Handle WarningLog case
            title = f"[Site: {site_id}] {message.warning_title}"
            labels = [base_label, f'site:{site_id}']
            if hasattr(message, 'warning_labels'):
                labels.extend(list(message.warning_labels))
        else:
            # Handle error case
            error_label = self.get_error_label(error_type) if error_type else "error:general"
            title = f"[Site: {site_id}] Error: {error_type or 'Unknown'}"
            labels = [base_label, error_label, f'site:{site_id}']
        
        # Build additional context section if provided
        context_section = ""
        if additional_context:
            context_section = "\n## Additional Context\n"
            for key, value in additional_context.items():
                context_section += f"- {key}: {value}\n"
        
        body = f"""
## Site Information
- Site ID: {site_id}
- Detection Time: {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}
- Category: {category.value}

## Details
{message}
{context_section}
## Processing Information
- This issue was automatically generated by the data processing pipeline
- Category: {base_label}
"""
        
        return self.repo.create_issue(
            title=title,
            body=body,
            labels=labels
        )

    def handle_processing_issue(self, site_id: str, message: str,
                              category: IssueType = IssueType.ERROR,
                              error_type: str = None,
                              additional_context: dict = None) -> Optional[object]:
        """
        Main method to handle a processing issue (error or warning) for a site.
        
        Args:
            site_id: Identifier for the site
            message: The warning or error message
            category: Whether this is an error or warning
            error_type: Type of error if this is an error
            additional_context: Optional dictionary of additional information
        """
        try:
            # Check for existing issue
            existing_issue = self.find_open_site_issue(site_id, category)
            
            if existing_issue:
                # Create comment body
                comment = f"Issue occurred again at {datetime.now().strftime('%Y-%m-%d %H:%M:%S UTC')}\n\n"
                comment += str(message)  # Add the warning messages
                if additional_context:
                    comment += "\n\n## Additional Context\n"
                    for key, value in additional_context.items():
                        comment += f"- {key}: {value}\n"
                
                existing_issue.create_comment(comment)
                self.logger.info(
                    f"Added comment to existing {category.value} for site {site_id}: "
                    f"{existing_issue.html_url}"
                )
                return existing_issue
            
            # Create new issue if none exists
            new_issue = self.create_site_issue(
                site_id=site_id,
                message=message,
                category=category,
                error_type=error_type,
                additional_context=additional_context
            )
            
            self.logger.info(
                f"Created new {category.value} for site {site_id}: {new_issue.html_url}"
            )
            return new_issue
            
        except Exception as e:
            self.logger.error(f"Error handling {category.value} for site {site_id}: {str(e)}")
            raise